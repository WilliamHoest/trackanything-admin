-- TrackanYthing Database Schema Migration
-- Complete normalized database structure for TrackAnything application

-- Create profiles table (extends auth.users)
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT,
    email TEXT,
    phone_number TEXT,
    company_name TEXT,
    contact_email TEXT,  -- Kept for backwards compatibility
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create platforms table
CREATE TABLE platforms (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT UNIQUE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create brands table
CREATE TABLE brands (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create topics table
CREATE TABLE topics (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    brand_id BIGINT NOT NULL REFERENCES brands(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create keywords table
CREATE TABLE keywords (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    text TEXT UNIQUE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create topic_keywords junction table
CREATE TABLE topic_keywords (
    topic_id BIGINT NOT NULL REFERENCES topics(id) ON DELETE CASCADE,
    keyword_id BIGINT NOT NULL REFERENCES keywords(id) ON DELETE CASCADE,
    PRIMARY KEY (topic_id, keyword_id)
);

-- Create mentions table
CREATE TABLE mentions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    caption TEXT NOT NULL,
    post_link TEXT UNIQUE NOT NULL,
    published_at TIMESTAMPTZ,
    platform_id BIGINT NOT NULL REFERENCES platforms(id),
    brand_id BIGINT NOT NULL REFERENCES brands(id) ON DELETE CASCADE,
    topic_id BIGINT NOT NULL REFERENCES topics(id) ON DELETE CASCADE,
    read_status BOOLEAN DEFAULT FALSE,
    notified_status BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create integration_configs table
CREATE TABLE integration_configs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    integration_name TEXT NOT NULL,
    webhook_url TEXT NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for better performance
CREATE INDEX idx_brands_profile_id ON brands(profile_id);
CREATE INDEX idx_topics_brand_id ON topics(brand_id);
CREATE INDEX idx_mentions_platform_id ON mentions(platform_id);
CREATE INDEX idx_mentions_brand_id ON mentions(brand_id);
CREATE INDEX idx_mentions_topic_id ON mentions(topic_id);
CREATE INDEX idx_mentions_published_at ON mentions(published_at);
CREATE INDEX idx_mentions_read_status ON mentions(read_status);
CREATE INDEX idx_mentions_notified_status ON mentions(notified_status);
CREATE INDEX idx_integration_configs_profile_id ON integration_configs(profile_id);

-- Enable Row Level Security (RLS)
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE brands ENABLE ROW LEVEL SECURITY;
ALTER TABLE topics ENABLE ROW LEVEL SECURITY;
ALTER TABLE keywords ENABLE ROW LEVEL SECURITY;
ALTER TABLE topic_keywords ENABLE ROW LEVEL SECURITY;
ALTER TABLE mentions ENABLE ROW LEVEL SECURITY;
ALTER TABLE integration_configs ENABLE ROW LEVEL SECURITY;
ALTER TABLE platforms ENABLE ROW LEVEL SECURITY;

-- RLS Policies for profiles
CREATE POLICY "Users can view own profile" ON profiles
    FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can update own profile" ON profiles
    FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Users can insert own profile" ON profiles
    FOR INSERT WITH CHECK (auth.uid() = id);

-- RLS Policies for brands
CREATE POLICY "Users can view own brands" ON brands
    FOR SELECT USING (auth.uid() = profile_id);

CREATE POLICY "Users can insert own brands" ON brands
    FOR INSERT WITH CHECK (auth.uid() = profile_id);

CREATE POLICY "Users can update own brands" ON brands
    FOR UPDATE USING (auth.uid() = profile_id);

CREATE POLICY "Users can delete own brands" ON brands
    FOR DELETE USING (auth.uid() = profile_id);

-- RLS Policies for topics
CREATE POLICY "Users can view own topics" ON topics
    FOR SELECT USING (
        auth.uid() IN (
            SELECT profile_id FROM brands WHERE id = topics.brand_id
        )
    );

CREATE POLICY "Users can insert own topics" ON topics
    FOR INSERT WITH CHECK (
        auth.uid() IN (
            SELECT profile_id FROM brands WHERE id = topics.brand_id
        )
    );

CREATE POLICY "Users can update own topics" ON topics
    FOR UPDATE USING (
        auth.uid() IN (
            SELECT profile_id FROM brands WHERE id = topics.brand_id
        )
    );

CREATE POLICY "Users can delete own topics" ON topics
    FOR DELETE USING (
        auth.uid() IN (
            SELECT profile_id FROM brands WHERE id = topics.brand_id
        )
    );

-- RLS Policies for keywords (all users can read, only authenticated users can create)
CREATE POLICY "Anyone can view keywords" ON keywords
    FOR SELECT TO authenticated USING (true);

CREATE POLICY "Authenticated users can insert keywords" ON keywords
    FOR INSERT TO authenticated WITH CHECK (true);

-- RLS Policies for topic_keywords
CREATE POLICY "Users can view own topic keywords" ON topic_keywords
    FOR SELECT USING (
        auth.uid() IN (
            SELECT b.profile_id 
            FROM topics t 
            JOIN brands b ON t.brand_id = b.id 
            WHERE t.id = topic_keywords.topic_id
        )
    );

CREATE POLICY "Users can insert own topic keywords" ON topic_keywords
    FOR INSERT WITH CHECK (
        auth.uid() IN (
            SELECT b.profile_id 
            FROM topics t 
            JOIN brands b ON t.brand_id = b.id 
            WHERE t.id = topic_keywords.topic_id
        )
    );

CREATE POLICY "Users can delete own topic keywords" ON topic_keywords
    FOR DELETE USING (
        auth.uid() IN (
            SELECT b.profile_id 
            FROM topics t 
            JOIN brands b ON t.brand_id = b.id 
            WHERE t.id = topic_keywords.topic_id
        )
    );

-- RLS Policies for mentions
CREATE POLICY "Users can view own mentions" ON mentions
    FOR SELECT USING (
        auth.uid() IN (
            SELECT profile_id FROM brands WHERE id = mentions.brand_id
        )
    );

CREATE POLICY "Users can insert own mentions" ON mentions
    FOR INSERT WITH CHECK (
        auth.uid() IN (
            SELECT profile_id FROM brands WHERE id = mentions.brand_id
        )
    );

CREATE POLICY "Users can update own mentions" ON mentions
    FOR UPDATE USING (
        auth.uid() IN (
            SELECT profile_id FROM brands WHERE id = mentions.brand_id
        )
    );

CREATE POLICY "Users can delete own mentions" ON mentions
    FOR DELETE USING (
        auth.uid() IN (
            SELECT profile_id FROM brands WHERE id = mentions.brand_id
        )
    );

-- RLS Policies for integration_configs
CREATE POLICY "Users can view own integrations" ON integration_configs
    FOR SELECT USING (auth.uid() = profile_id);

CREATE POLICY "Users can insert own integrations" ON integration_configs
    FOR INSERT WITH CHECK (auth.uid() = profile_id);

CREATE POLICY "Users can update own integrations" ON integration_configs
    FOR UPDATE USING (auth.uid() = profile_id);

CREATE POLICY "Users can delete own integrations" ON integration_configs
    FOR DELETE USING (auth.uid() = profile_id);

-- RLS Policies for platforms (all users can read)
CREATE POLICY "Anyone can view platforms" ON platforms
    FOR SELECT TO authenticated USING (true);

CREATE POLICY "Authenticated users can insert platforms" ON platforms
    FOR INSERT TO authenticated WITH CHECK (true);

-- Insert default platforms
INSERT INTO platforms (name) VALUES 
    ('Politiken'),
    ('DR'),
    ('Google News'),
    ('Reddit'),
    ('YouTube'),
    ('Quora'),
    ('Twitter'),
    ('Facebook'),
    ('Instagram'),
    ('LinkedIn')
ON CONFLICT (name) DO NOTHING;

-- Create function to automatically create profile on user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.profiles (id, contact_email)
    VALUES (NEW.id, NEW.email);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to create profile when user signs up
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();